<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
  <title>QSPI to eMMC boot for Production SOM &mdash; Boot SOM Firmware 2022.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="QSPI to PXE/tftp boot" href="bootfw_qspi_pxetftp_boot.html" />
    <link rel="prev" title="Stitching QSPI Image" href="bootfw_qspi_stitching.html" /> 
</head>

<body class="wy-body-for-nav">

<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
<!-- End Google Tag Manager --> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../index.html" class="icon icon-home"> Boot SOM Firmware
            <img src="../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2022.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">SOM</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/">Landing Page</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/Kria_doc_map/map.htm">Kria Adventure Map</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/creating_applications.html">Application Development</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/ubuntu_support.html">Ubuntu Support</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/bootfw.html">Boot Firmware</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/openamp.html">OpenAMP</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/dfx.html">Dynamic Function eXchange</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/ipmi_eeprom.html">IPMI EEPROM Design Guide</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/yocto.html">Yocto Support</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/xen.html">XEN Support</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/kd240-docs.html">Kria KD240</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/kv260-docs.html">Kria KV260</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/kr260-docs.html">Kria KR260</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/KRS/">Kria Robotics Stack</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Boot Firmware</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="bootfw_overview.html">Boot Firmware Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_image_selector.html">Image Selector</a></li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_image_recovery.html">Boot Image Recovery Tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_pmu_config_obj.html">PMU Overlay Config Object</a></li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_uboot_handoff.html">U-Boot Handoff</a></li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_boot.bin_generation.html">Generating <code class="docutils literal notranslate"><span class="pre">BOOT.bin</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_qspi_stitching.html">Stitching QSPI Image</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">QSPI to eMMC boot for Production SOM</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prerequisite">Prerequisite</a></li>
<li class="toctree-l2"><a class="reference internal" href="#steps">Steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#export-xsa-file-with-production-som-and-carrier-card-peripheral-support">0. Export .XSA file with Production SOM and Carrier Card Peripheral Support</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#getting-the-base-starter-kit-vivado-design">Getting the base Starter Kit Vivado design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-production-som-only-features">Add Production SOM only Features</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#program-production-som-with-qspi-binary">1. Program Production SOM with QSPI binary</a></li>
<li class="toctree-l3"><a class="reference internal" href="#program-production-som-emmc-with-linux-image">2. Program Production SOM eMMC with Linux Image</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#a-program-production-som-emmc-with-image-recovery-app">2A Program Production SOM eMMC with Image Recovery App</a></li>
<li class="toctree-l4"><a class="reference internal" href="#b-program-production-som-emmc-with-linux-image-using-linux">2B Program Production SOM eMMC with Linux Image using Linux</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reboot-in-qspi-mode">3. Reboot in QSPI mode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#license">License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bootfw_qspi_pxetftp_boot.html">QSPI to PXE/tftp boot</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Boot SOM Firmware</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>QSPI to eMMC boot for Production SOM</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/docs/bootfw_qspi_emmc_boot.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="qspi-to-emmc-boot-for-production-som">
<h1>QSPI to eMMC boot for Production SOM<a class="headerlink" href="#qspi-to-emmc-boot-for-production-som" title="Permalink to this heading">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>The production SOM has an eMMC device populated, whereas the Starter Kit SOMs do not. Therefore, instead of Starter Kit’s QSPI-&gt;SD two stage boot process, developer can do a QSPI -&gt; eMMC two stage process on the production SOM. This page gives an example of how to boot from QSPI -&gt; eMMC for a K26 production SOM that is mounted on a KV260 or KR260 carrier card. However, it will also apply for a K24 production SOM (I grade or C grade) on a KD240 carrier card. Note that removal of the SOM from an AMD produced Starter Kit voids its warranty. This workflow is only intended to provide an example for customers creating their own carrier card design and wanting to make use of a similar two-stage boot methodology.</p>
<p>User can also use the traditional monolithic boot (from eMMC) for production SOMs by using eMMC boot mode and placing boot files in eMMC. This method is not covered by this document and also requires user to set the BOOT_MODE pins to eMMC on their production carrier card.</p>
<p>This tutorial is targeted for 2022.2 releases and tool chains.</p>
</div>
<div class="section" id="prerequisite">
<h2>Prerequisite<a class="headerlink" href="#prerequisite" title="Permalink to this heading">¶</a></h2>
<ol class="simple">
<li><p>Have finished Getting Started with Kria SOM <a class="reference external" href="https://www.xilinx.com/products/som/kria/kv260-vision-starter-kit/kv260-getting-started/getting-started.html">KV260</a> or <a class="reference external" href="https://www.xilinx.com/products/som/kria/kr260-robotics-starter-kit/kr260-getting-started/getting-started.html">KR260</a>or <a class="reference external" href="https://www.xilinx.com/products/som/kria/kd240-drives-starter-kit/kd240-getting-started/getting-started.html">KD240</a></p></li>
<li><p>Have read <a class="reference internal" href="bootfw_overview.html"><span class="doc">bootfw overview</span></a> and its associated contents</p></li>
<li><p>Vivado or Vivado Lab installed on host computer</p></li>
<li><p>have gone through <a class="reference external" href="https://xilinx.github.io/kria-apps-docs/yocto/build/html/docs/yocto_kria_support.html">Yocto flow</a> on host computer</p></li>
<li><p>PetaLinux installed on host computer (optional)</p></li>
</ol>
</div>
<div class="section" id="steps">
<h2>Steps<a class="headerlink" href="#steps" title="Permalink to this heading">¶</a></h2>
<p>There are many different ways to get a production SOM to boot from QSPI to eMMC. The following steps have been verified with Kria SOM:</p>
<ol>
<li><p><a class="reference external" href="#0-export-xsa-file-with-production-som-and-carrier-card-peripheral-support">Create Vivado project and export .xsa file with Production SOM + Carrier Card peripheral support</a></p></li>
<li><p><a class="reference external" href="#1-program-production-som-with-qspi-binary">Program production SOM with a QSPI binary using XSDB/XSCT and u-boot</a></p></li>
<li><p><a class="reference external" href="#2-program-production-som-emmc-with-linux-image">Program production SOM eMMC with a Linux image</a>, there are 2 ways to do this:</p>
<p>2.A <a class="reference external" href="#2a-program-production-som-emmc-with-image-recovery-app">Program the production SOM eMMC with Image Recovery App</a> (does not support Ubuntu)</p>
<p>2.B <a class="reference external" href="#2b-program-production-som-emmc-with-linux-image-using-linux">Program the production SOM eMMC with Linux image targeted for eMMC using Linux booted from SD card with two steps</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mf">2.</span><span class="n">B</span><span class="o">.</span><span class="n">a</span> <span class="p">[</span><span class="n">Boot</span> <span class="n">Linux</span> <span class="n">through</span> <span class="n">SD</span><span class="p">](</span><span class="c1">#2ba-boot-linux-through-sd)</span>

 <span class="mf">2.</span><span class="n">B</span><span class="o">.</span><span class="n">b</span> <span class="p">[</span><span class="n">Write</span> <span class="n">to</span> <span class="n">eMMC</span> <span class="ow">in</span> <span class="n">Linux</span><span class="p">](</span><span class="c1">#2bb-write-to-emmc-in-linux)</span>
</pre></div>
</div>
</li>
<li><p><a class="reference external" href="#3-reboot-in-qspi-mode">Reboot in QSPI mode</a></p></li>
</ol>
<p>A graphical representation of the flow to help guide through the many options of doing each step:</p>
<p><img alt="media" src="../_images/emmc_boot_flow.PNG" /></p>
<div class="section" id="export-xsa-file-with-production-som-and-carrier-card-peripheral-support">
<h3>0. Export .XSA file with Production SOM and Carrier Card Peripheral Support<a class="headerlink" href="#export-xsa-file-with-production-som-and-carrier-card-peripheral-support" title="Permalink to this heading">¶</a></h3>
<p>We need to first create a Vivado project that has both Production SOM features (such as eMMC support for K24c/K24i and K26, and just for K24i - DDR ECC enablement) and carrier card peripheral features.This will allow us to later generate QSPI boot images or wic images with features from both, enabling accessing eMMC and Ethernet at the same time. The easiest way is to start from a Starter Kit SOM, as that has all the CC peripheral support, and we just need to enable eMMC, and in the case of K24i, DDR ECC.</p>
<div class="section" id="getting-the-base-starter-kit-vivado-design">
<h4>Getting the base Starter Kit Vivado design<a class="headerlink" href="#getting-the-base-starter-kit-vivado-design" title="Permalink to this heading">¶</a></h4>
<p>The base hardware project can be obtained either through PetaLinux or through Vivado board files.</p>
<div class="section" id="petalinux">
<h5>PetaLinux<a class="headerlink" href="#petalinux" title="Permalink to this heading">¶</a></h5>
<p>Download the Starter Kit BSP (KV260/KR260 etc) pointed to from the <a class="reference external" href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+K26+SOM#PetaLinux-Board-Support-Packages">Wiki page</a>. Extract the BSP. We will use KR260 2022.2 BSP as an example here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
petalinux-create -t project -s xilinx-kr260-starterkit-v2022.2-10141622.bsp
cd xilinx-kr260-starterkit-2022.2/
```
</pre></div>
</div>
<p>Use Vivado and open  <code class="docutils literal notranslate"><span class="pre">hardware/xilinx-kr260-starterkit-2022.2/kr260_starter_kit.xpr</span></code> in the folder.</p>
</div>
<div class="section" id="board-files">
<h5>Board Files<a class="headerlink" href="#board-files" title="Permalink to this heading">¶</a></h5>
<p>Alternatively, follow instructions in <a class="reference external" href="https://xilinx.github.io/kria-apps-docs/creating_applications/generate_vivado_project_boardfile.html">Generate Vivado Project from Board Files</a> to generate a base hardware project from board files.</p>
</div>
</div>
<div class="section" id="add-production-som-only-features">
<h4>Add Production SOM only Features<a class="headerlink" href="#add-production-som-only-features" title="Permalink to this heading">¶</a></h4>
<p>Click on <code class="docutils literal notranslate"><span class="pre">IP</span> <span class="pre">INTEGRATOR</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Open</span> <span class="pre">Block</span> <span class="pre">Design</span></code>, and double click on <code class="docutils literal notranslate"><span class="pre">ZYNQ</span> <span class="pre">UltraSCALE+</span> <span class="pre">PS</span></code> block to open the configuration wizard for the PS.</p>
<p>In the configuration wizard, go to <code class="docutils literal notranslate"><span class="pre">I/O</span> <span class="pre">Configuration</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Low</span> <span class="pre">Speed</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Memory</span> <span class="pre">Interfaces</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">SD</span></code>, and check <code class="docutils literal notranslate"><span class="pre">SD0</span></code>, and match the configuration of SD 0 to that of the snippet below:</p>
<p><img alt="image" src="../_images/enable_emmc_marked.png" /></p>
<p>Then click on <code class="docutils literal notranslate"><span class="pre">OKAY</span></code>, save the project, and <code class="docutils literal notranslate"><span class="pre">IP_ITEGRATOR</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Generate</span> <span class="pre">Block</span> <span class="pre">Design</span></code>. After that is finished, click on <code class="docutils literal notranslate"><span class="pre">File</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Export</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Export</span> <span class="pre">Hardware</span></code>, leave the default settings, and choose a xsa file name such as <code class="docutils literal notranslate"><span class="pre">kr260_starter_kit_emmc8bit</span></code>, and click <code class="docutils literal notranslate"><span class="pre">next</span></code> until <code class="docutils literal notranslate"><span class="pre">finish</span></code>. This would generate an <code class="docutils literal notranslate"><span class="pre">kr260_starter_kit_emmc8bit.xsa</span></code> file.</p>
<p>Note that if you are using a K24i - you will need to also enable the DDR ECC feature - as that is not enabled on K24 Production SOM or K24c.</p>
</div>
</div>
<div class="section" id="program-production-som-with-qspi-binary">
<h3>1. Program Production SOM with QSPI binary<a class="headerlink" href="#program-production-som-with-qspi-binary" title="Permalink to this heading">¶</a></h3>
<p>Unlike the Starter Kit SOM, the production SOM is shipped without QSPI pre-populated. A developer must first program QSPI with the appropriate boot firmware so that SOM will boot to U-Boot via the QSPI contents and then hand off to the Linux OS image in eMMC. The full QSPI binary for Starter Kit SOM is not released, however, each components can be generated as outlined in <a class="reference internal" href="bootfw_overview.html"><span class="doc">bootfw overview</span></a> and its pages. As a reference and an example for this guide, developer need to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="kn">import</span> <span class="nn">the</span> <span class="o">.</span><span class="n">xsa</span> <span class="n">generated</span> <span class="ow">in</span> <span class="p">[</span><span class="n">previous</span> <span class="n">step</span><span class="p">](</span><span class="c1">#0-export-xsa-file-with-production-som-and-carrier-card-peripheral-support)</span>
<span class="mf">2.</span> <span class="n">use</span> <span class="p">[</span><span class="n">Yocto</span> <span class="n">support</span> <span class="n">on</span> <span class="n">Kria</span><span class="p">](</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">xilinx</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">kria</span><span class="o">-</span><span class="n">apps</span><span class="o">-</span><span class="n">docs</span><span class="o">/</span><span class="n">yocto</span><span class="o">.</span><span class="n">html</span><span class="p">)</span> <span class="n">combined</span> <span class="k">with</span> <span class="p">[</span><span class="n">importing</span> <span class="n">new</span> <span class="o">.</span><span class="n">xsa</span> <span class="n">to</span> <span class="n">Yocto</span><span class="p">](</span><span class="o">../../../</span><span class="n">yocto</span><span class="o">/</span><span class="n">source</span><span class="o">/</span><span class="n">docs</span><span class="o">/</span><span class="n">yocto_kria_support</span><span class="o">.</span><span class="n">md</span><span class="c1">#importing-a-new-xsa-file)</span>
<span class="mf">3.</span> <span class="n">update</span> <span class="n">the</span> <span class="n">dtb</span> <span class="n">file</span> <span class="n">to</span> <span class="n">include</span> <span class="n">CC</span> <span class="n">peripherals</span>
</pre></div>
</div>
<p>to generate a QSPI binary that supports production SOM + CC peripheral. Below are the commands expected (after repo setup, using 2023.2 as an example here):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``` bash
#&lt;MACHINE name&gt; needs to be production som build - k26-sm, or k24i-sm, or k24c-sm
repo init -u https://github.com/Xilinx/yocto-manifests.git -b rel-v2023.2
repo sync
repo start rel-v2023.2 --all
source setupsdk
#modify sources/meta-kria/conf/machine/&lt;MACHINE name&gt;.conf with the following:
            HDF_BASE = &quot;file://&quot;
            HDF_PATH = &quot;/path/to/XSA/file.xsa&quot;
            UBOOT_DT_FILES = &quot;zynqmp-sck-&lt;cc name&gt;-g-rev&lt;rev&gt;.dts&quot; 
                #e.g. zynqmp-sck-kd-g-revA.dtb or zynqmp-sck-kr-g-revB.dtb or zynqmp-sck-kv-g-revB.dtb; you can find the dtb intended for each CC card by this command:
                # grep  sources/meta-kria/conf/machine/k2*-smk-k*.conf UBOOT_DTFILE_PREFIX
#modify sources/meta-kria/recipes-bsp/bootbin/xilinx-bootbin_1.0.bbappend with the following:
            BIF_PARTITION_IMAGE[u-boot-xlnx-fit-blob] = &quot;${RECIPE_SYSROOT}/boot/devicetree/SMK-zynqmp-sck-&lt;cc name&gt;-g-rev&lt;rev&gt;.dtb&quot; # e.g. SMK-zynqmp-sck-kd-g-revA.dtb or SMK-zynqmp-sck-kr-g-revB.dtb or SMK-zynqmp-sck-kv-g-revB.dtb
MACHINE=&lt;MACHINE name&gt; bitbake kria-qspi
```
</pre></div>
</div>
<p>Once you have a QSPI binary .bin file in <code class="docutils literal notranslate"><span class="pre">$TMPDIR/deploy/images/&lt;MACHINE</span> <span class="pre">name&gt;</span></code>, it is time to program it to the board. Mount the Kria production SOM onto a carrier card, connect it to a host computer using micro-usb cable or a AMD Platform cable. Leave SD card slot empty and connect to power.</p>
<p>To program the QSPI using XSDB/XSCT, download <a class="reference external" href="./example_src/boot.tcl">boot.tcl</a> file and put them in a &lt;working_folder/&gt; along with <code class="docutils literal notranslate"><span class="pre">&lt;QSPI_image&gt;.bin,</span> <span class="pre">bl31.elf</span> <span class="pre">pmufw.elf</span> <span class="pre">system.dtb</span> <span class="pre">u-boot.elf</span> <span class="pre">zynqmp_fsbl.elf</span></code> found in  <code class="docutils literal notranslate"><span class="pre">$TMPDIR/deploy/images/&lt;MACHINE</span> <span class="pre">name&gt;</span></code> from previous step.</p>
<p>Connect the serial port of carrier card with a uart listener so we can work in u-boot. Power on the board.</p>
<p>In xsdb/xsct, cd to &lt;working_folder/&gt; and source boot.tcl:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
source boot.tcl
```
</pre></div>
</div>
<p>This will boot u-boot on the board. In the uart listener there should be print outs from u-boot. Press “enter” on uart listener to be at u-boot prompt, go back to xsdb and copy the QSPI image to DDR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
dow -force -data &lt;QSPI image&gt;.bin &lt;ddr address&gt;
```
</pre></div>
</div>
<p>example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
dow -force -data &lt;QSPI image&gt;.bin 0x80000
```
</pre></div>
</div>
<p>In u-boot, write the QSPI image in DDR to QSPI:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``` shell
ZynqMP&gt; sf probe 0x0 0x0 0x0 
ZynqMP&gt; sf erase &lt;offset address on flash&gt; &lt;greater than the size qspi bin&gt;
ZynqMP&gt; sf write &lt;ddr address&gt; &lt;offset address on flash&gt; &lt;greater than the size qspi bin&gt;
```
</pre></div>
</div>
<p>example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``` shell
ZynqMP&gt; sf probe 0x0 0x0 0x0 
ZynqMP&gt; sf erase 0x0 0x3000000  
ZynqMP&gt; sf write 0x80000 0x0 0x3000000 
```
</pre></div>
</div>
<p>Close XSDB - leaving it open/connected may interfere with ZynqMPSoC’s operation.</p>
<p>Now QSPI is programmed with an image that contains boot.bin files and image recovery app. They will be used in the following section.</p>
</div>
<div class="section" id="program-production-som-emmc-with-linux-image">
<h3>2. Program Production SOM eMMC with Linux Image<a class="headerlink" href="#program-production-som-emmc-with-linux-image" title="Permalink to this heading">¶</a></h3>
<p>There are two ways to program the eMMC - using image recovery application or using Linux.</p>
<div class="section" id="a-program-production-som-emmc-with-image-recovery-app">
<h4>2A Program Production SOM eMMC with Image Recovery App<a class="headerlink" href="#a-program-production-som-emmc-with-image-recovery-app" title="Permalink to this heading">¶</a></h4>
<p>The Image recovery tool has an option to upload an image file to eMMC on a production SOM. For details on set-up and use of the Recovery Tool, see <a class="reference external" href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+K26+SOM#Boot-Image-Recovery-Tool">Boot Image Recovery Tool on kria SOM Wiki</a>.</p>
<p>The recovery tool currently only support .wic image upload and has a limit of 4GB upload file size.</p>
<p>Yocto generated image are around 2GB and will be able to be uploaded to eMMC via recovery tool directly. Refer to <a class="reference external" href="https://xilinx.github.io/kria-apps-docs/yocto/build/html/docs/yocto_kria_support.html">Yocto Kria support</a> page to generate a wic image for your production SOM.</p>
<p>PetaLinux generated image are around 8GB by default, so we will need to shrink it down. In this example we will limit the wic image targeted to eMMC to 2GB, using 0.5G for the boot partition and 1.5G for rootfs. Update the build/rootfs.wks in PetaLinux work folder before generating the wic image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
# in 2023.1 and older, need to use --ondisk mmcblk0 to target to emmc
part /boot --source bootimg-partition --ondisk mmcblk0 --fstype=vfat --label boot --active --align 4 --fixed-size 500M
part / --source rootfs --ondisk mmcblk0 --fstype=ext4 --label root --align 4 --fixed-size 1500M
# in 2023.2 and later, --use-label allows wic to be in either emmc or sd
part /boot --source bootimg-partition --use-label --fstype=vfat --label boot --active --align 4 --fixed-size 2G
part /     --source rootfs            --use-label --fstype=ext4 --label root          --align 4 --fixed-size 4G
```
</pre></div>
</div>
<p>Note that after booting, use <a class="reference external" href="https://xilinx.github.io/kria-apps-docs/creating_applications/2022.1/build/html/docs/target.html#resize-part">re-size</a> tool to expand rootfs.</p>
<p>Then generate the .wic image with the .wks file and targeting running out of eMMC (mmcblk0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
petalinux-package --wic --bootfiles &quot;ramdisk.cpio.gz.u-boot boot.scr Image system.dtb&quot; --wks build/rootfs.wks
```
</pre></div>
</div>
<p>The wic image can now be uploaded through Image Recovery app.</p>
</div>
<div class="section" id="b-program-production-som-emmc-with-linux-image-using-linux">
<h4>2B Program Production SOM eMMC with Linux Image using Linux<a class="headerlink" href="#b-program-production-som-emmc-with-linux-image-using-linux" title="Permalink to this heading">¶</a></h4>
<p>To write to eMMC from Linux, we first need to boot Linux that has eMMC awareness and ethernet capabilities. This is because the Linux images can be bigger than DDR space. Therefore, traditional eMMC programming <a class="reference external" href="https://support.xilinx.com/s/article/67157?language=en_US">through xsdb and ddr</a> will not work in this case. We need to boot to a Linux image from SD, then transfer the final image file directly from host computer to eMMC on the Starter Kit through the network.</p>
<p>Please also note that the Starter Kit PetaLinux images (.wic files) and Ubuntu image (.img file) released do not have emmc support and are targeted to boot from SD card and not eMMC. The images targeted to eMMC will need to be re-generated with the appropriate hardware (eMMC enabled). In 2023.1 and older, the wic images also need to be generated with <code class="docutils literal notranslate"><span class="pre">disk-name</span> <span class="pre">&quot;mmcblk0&quot;</span></code> in petalinux-package to target it to boot out of eMMC (in 2023.2 and newer, .wks file has <code class="docutils literal notranslate"><span class="pre">--use-label</span></code> which allows the wic image to work out of eMMC or SD card). The production SOM (e.g. <a class="reference external" href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+K26+SOM#PetaLinux-Board-Support-Packages">Production K26 SOM</a>) BSP’s prebuilt wic image, however, has emmc support and are targeted to boot out of eMMC. It can be used as an example image to be programmed into the eMMC.</p>
<div class="section" id="b-a-boot-linux-through-sd">
<h5>2.B.a Boot Linux through SD<a class="headerlink" href="#b-a-boot-linux-through-sd" title="Permalink to this heading">¶</a></h5>
<p>We need to boot a Linux with eMMC and Ethernet support from SD card. The released K26 production SOM BSP by default has eMMC support but no awareness of any Starter Kit peripherals including Ethernet. The Starter Kit BSPs has support for Ethernet, but no eMMC support as the default Starter Kit SOM do not have eMMC. Therefore, we will need to create our own Linux wic image that has both Ethernet and eMMC support. We have already created a .xsa file with support for both in <a class="reference external" href="#0-export-xsa-file-with-production-som-and-carrier-card-peripheral-support">step 0</a>, we will leverage the .xsa created there to generate a new .eic image. This can be done in either Yocto oe PetaLinux. Follow either<a class="reference external" href="#generate-with-new-xsa-in-yocto">Generate with new .xsa in Yocto</a> or  <a class="reference external" href="#generate-with-new-xsa-in-petalinux">Generate with new .xsa in PetaLinux</a>:</p>
<div class="section" id="generate-with-new-xsa-in-yocto">
<h6>Generate with new .xsa in Yocto<a class="headerlink" href="#generate-with-new-xsa-in-yocto" title="Permalink to this heading">¶</a></h6>
<p>Refer to <a class="reference external" href="../../../yocto/source/docs/yocto_kria_support.md#importing-a-new-xsa-file">Importing a New XSA File</a> for steps to import new .xsa file. You have already done most of the steps in <a class="reference external" href="#1-program-production-som-with-qspi-binary">QSPI generation ins step 1</a>, you just need the following command to also generate a new .wic image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```bash
MACHINE=&lt;MACHINE name&gt; bitbake kria-image-full-cmdline 
```
</pre></div>
</div>
<p>Now you have a wic image in <code class="docutils literal notranslate"><span class="pre">$yocto_project/build/tmp/deploy/images/&lt;machine</span> <span class="pre">name&gt;/</span></code> to program into SD card.</p>
</div>
<div class="section" id="generate-with-new-xsa-in-petalinux">
<h6>Generate with new .xsa in PetaLinux<a class="headerlink" href="#generate-with-new-xsa-in-petalinux" title="Permalink to this heading">¶</a></h6>
<p>This section shows how to import the new hardware configuration into the PetaLinux project. For more details review <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1144-petalinux-tools-reference-guide/Steps-to-Import-Hardware-Configuration">UG1144</a>.</p>
<p>Here are the example commands to import the new .xsa and regenerate wic image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
petalinux-config --get-hw-description hardware/xilinx-kr260-starterkit-2022.2/kr260_starter_kit_emmc8bit.xsa #this will bring up a config GUI - just exit and let it configure
petalinux-build
petalinux-package --boot --u-boot --force

#for KV260 on 2023.1 and earlier, package to SD on mmcblk1:
petalinux-package --wic --images-dir images/linux/ --bootfiles &quot;ramdisk.cpio.gz.u-boot,boot.scr,Image,system.dtb,system-zynqmp-sck-kv-g-revB.dtb&quot; --disk-name &quot;mmcblk1&quot;
#for KV260 on 2023.2 and later, --disk-name is not supported, and .wks file has --use-label to allow booting out of eMMC or SD
petalinux-package --wic --images-dir images/linux/ --bootfiles &quot;ramdisk.cpio.gz.u-boot,boot.scr,Image,system.dtb,system-zynqmp-sck-kv-g-revB.dtb&quot;

#for KR260 on 2023.1 and earlier, package to SD on sda/usb:
petalinux-package --wic --images-dir images/linux/ --bootfiles &quot;ramdisk.cpio.gz.u-boot,boot.scr,Image,system.dtb,system-zynqmp-sck-kr-g-revB.dtb&quot; --disk-name &quot;sda&quot;
#for KR260 on 2023.2 and later, --disk-name is not supported, and .wks file has --use-label to allow booting out of eMMC or SD
petalinux-package --wic --images-dir images/linux/ --bootfiles &quot;ramdisk.cpio.gz.u-boot,boot.scr,Image,system.dtb,system-zynqmp-sck-kr-g-revB.dtb&quot;

#for KD240, supports starts on 2023.2, .wks file has --use-label to allow booting out of eMMC or SD
petalinux-package --wic --images-dir images/linux/ --bootfiles &quot;ramdisk.cpio.gz.u-boot,boot.scr,Image,system.dtb,system-zynqmp-sck-kd-g-revA.dtb&quot; 
```
</pre></div>
</div>
<p>Now you have a wic image in <code class="docutils literal notranslate"><span class="pre">$petalinux_project/images/linux/</span></code> to program into SD card.</p>
</div>
<div class="section" id="boot-linux-with-emmc-and-peripheral-support">
<h6>Boot Linux with eMMC and Peripheral Support<a class="headerlink" href="#boot-linux-with-emmc-and-peripheral-support" title="Permalink to this heading">¶</a></h6>
<p>Plug the SD card into SD slot and power on.</p>
<p>If doing this for the second time (e.g. if eMMC already have a Linux image), both u-boot and Linux will choose to boot to eMMC prior to try to boot to SD. In order to boot to SD instead of eMMC, press “enter” when u-boot prompts to stop autoboot. In u-boot, first wipe the eMMC, and then use commands to boot to PetaLinux image in sd:</p>
<p>Example commands to wipe eMMC, it may vary depending on what was previously in eMMC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```bash
ZynqMP&gt; mmc part #check existing partition map
ZynqMP&gt; mmc partconf 0 1 0 0 # set boot partition to user partition to allow writes/erase
ZynqMP&gt; mmc dev 0 0 #switch to the user partition (should be partition 1 according to outputs from previous command)
ZynqMP&gt; mmc read 0x80000 0x7fffffff 1 # read a large chunk so it display the max size as below:
    # MMC read: dev # 0, block # 2147483647, count 1 ... MMC: block number 0x80000000 exceeds max(0x1da4000)
    # 0 blocks read: ERROR
ZynqMP&gt; mmc erase 0 0x1da4000 # or whatever max output from previous command    
ZynqMP&gt; mmc dev 0 1 #switch to the boot partition (should be partition 1 according to outputs from previous command)
ZynqMP&gt; mmc read 0x80000 0x7fffffff 1 # read a large chunk so it display the max size
ZynqMP&gt; mmc erase 0 &lt;max size&gt; #erase the partition
ZynqMP&gt; mmc dev 0 2 #switch to the rootfs partition (should be partition 2 according to outputs from previous command)
ZynqMP&gt; mmc read 0x80000 0x7fffffff 1 # read a large chunk so it display the max size
ZynqMP&gt; mmc erase 0 &lt;max size&gt; #erase the partition
```
</pre></div>
</div>
<p>Example commands to force u-boot boot out of SD (alternatively you can just power cycle again and let u-boot automatically pick SD card to boot from, since eMMC has been wiped clean):</p>
<p>For KV260, SD is mapped to mmc1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``` bash
ZynqMP&gt; setenv boot_targets mmc1
ZynqMP&gt; run bootcmd_mmc1
```
</pre></div>
</div>
<p>For KR260, SD is behind the USB hub:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``` bash
ZynqMP&gt; setenv boot_targets usb0
ZynqMP&gt; run bootcmd_usb0
```
</pre></div>
</div>
</div>
</div>
<div class="section" id="b-b-write-to-emmc-in-linux">
<h5>2.B.b Write to eMMC in Linux<a class="headerlink" href="#b-b-write-to-emmc-in-linux" title="Permalink to this heading">¶</a></h5>
<p>Once booted to Linux, you should be able to see  /dev/mmcblk0 -  the eMMC partition. Note on KV260 starter kit, SD is mapped to SD1, while on KR260, SD is mapped to USB. So on KV260 there is also /dev/mmcblk1 - the SD partition.  To double check, you can use this command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```shell
cat /sys/class/mmc_host/mmc0/*/uevent
cat /sys/class/mmc_host/mmc1/*/uevent
```
</pre></div>
</div>
<p>if <code class="docutils literal notranslate"><span class="pre">MMC_TYPE=MMC</span></code>, it is an eMMC device, if <code class="docutils literal notranslate"><span class="pre">MMC_TYPE=SD</span></code>, it is a SD device.</p>
<p>Next, transfer the image file targeted for eMMC over using your favorite method (such as scp, nfs, copying over SD card etc…).</p>
<p>Using scp:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>on target:

```shell
sudo chmod 666 /dev/mmcblk0 #add write permission for user
ifconfig #check ip address
```

on host computer, copy the image for eMMC over (a .img file for Ubuntu or .wic file for PetaLinux, built to boot out of eMMC)

```
scp &lt;image&gt; petalinux@&lt;ip address&gt;:/dev/mmcblk0
```
</pre></div>
</div>
<p>using nfsroot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>On host computer, where &lt;image&gt; is a .img file for Ubuntu or .wic file for PetaLinux, built to boot out of eMMC:

```shell
nfsroot3 &lt;path to be mounted where image is present&gt;
```

On target:

```shell
mkdir /nfsroot
mount -t nfs -o nolock,proto=tcp,port=2049 10.10.70.101:/exports/root /nfsroot
#Use DD command to flash image
dd if=/nfsroot/&lt;image&gt; of=/dev/mmcblk0
``` 
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="reboot-in-qspi-mode">
<h3>3. Reboot in QSPI mode<a class="headerlink" href="#reboot-in-qspi-mode" title="Permalink to this heading">¶</a></h3>
<p>Next, boot the board in QSPI - simply power cycle and it will boot from QSPI to eMMC.</p>
<p>Refer to <a class="reference internal" href="bootfw_uboot_handoff.html"><span class="doc">u-boot handoff</span></a> “Prioritized Boot Order” section, on 22.1 or later, u-boot will prioritize handling off from QSPI to eMMC on production SOM, if images are available.</p>
</div>
</div>
<div class="section" id="license">
<h2>License<a class="headerlink" href="#license" title="Permalink to this heading">¶</a></h2>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at
<a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p class="sphinxhide" align="center">Copyright&copy; 2023 Advanced Micro Devices, Inc</p></div>
</div>


           </div>
          </div>
          
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="bootfw_qspi_stitching.html" class="btn btn-neutral float-left" title="Stitching QSPI Image" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bootfw_qspi_pxetftp_boot.html" class="btn btn-neutral float-right" title="QSPI to PXE/tftp boot" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2024, Advanced Micro Devices, Inc.
      <span class="lastupdated">Last updated on February 01, 2024.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>